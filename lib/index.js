"use strict";
/**
 * Created by user on 2019/4/30.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const findYarnWorkspaceRoot = require("find-yarn-workspace-root2");
const pkgDir = require("pkg-dir");
const diff_service_1 = require("yarn-lock-diff/lib/diff-service");
const formatter_1 = require("yarn-lock-diff/lib/formatter");
const debug_color2_1 = require("debug-color2");
const path = require("path");
const fs = require("fs-extra");
const util_1 = require("debug-color2/lib/util");
exports.console = new debug_color2_1.Console2();
exports.consoleDebug = new debug_color2_1.Console2(null, {
    label: true,
    time: true,
});
function findRoot(options, throwError) {
    if (!options.cwd) {
        throw new TypeError(`options.cwd is '${options.cwd}'`);
    }
    let ws;
    if (!options.skipCheckWorkspace) {
        ws = findYarnWorkspaceRoot(options.cwd);
    }
    let pkg = pkgDir.sync(options.cwd);
    if (pkg == null && (options.throwError || (options.throwError == null && throwError))) {
        let err = new TypeError(`can't found package root from target directory '${options.cwd}'`);
        throw err;
    }
    let hasWorkspace = ws && ws != null;
    let isWorkspace = hasWorkspace && ws === pkg;
    let root = hasWorkspace ? ws : pkg;
    return {
        pkg,
        ws,
        hasWorkspace,
        isWorkspace,
        root,
    };
}
exports.findRoot = findRoot;
function yarnLockDiff(yarnlock_old, yarnlock_new) {
    let r2 = [];
    let r = diff_service_1.DiffService.buildDiff([yarnlock_old], [yarnlock_new])
        .map(formatter_1.FormatterService.buildDiffTable)
        .map(r => r2.push(r));
    return r2[0];
}
exports.yarnLockDiff = yarnLockDiff;
function fsYarnLock(root) {
    let yarnlock_file = path.join(root, 'yarn.lock');
    let yarnlock_exists = fs.existsSync(yarnlock_file);
    let yarnlock_old = yarnlock_exists && fs.readFileSync(yarnlock_file, 'utf8') || null;
    return {
        yarnlock_file,
        yarnlock_exists,
        yarnlock_old,
    };
}
exports.fsYarnLock = fsYarnLock;
function lazyFlags(keys, argv) {
    return keys.map(key => argv[key] && '--' + key);
}
exports.lazyFlags = lazyFlags;
exports.chalkByConsole = util_1.createFnChalkByConsole(exports.console);
exports.default = exports;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7O0FBRUgsbUVBQW9FO0FBQ3BFLGtDQUFtQztBQUNuQyxrRUFBOEQ7QUFDOUQsNERBQWdFO0FBQ2hFLCtDQUF3QztBQUN4Qyw2QkFBOEI7QUFDOUIsK0JBQWdDO0FBQ2hDLGdEQUErRDtBQUVsRCxRQUFBLE9BQU8sR0FBRyxJQUFJLHVCQUFRLEVBQUUsQ0FBQztBQUV6QixRQUFBLFlBQVksR0FBRyxJQUFJLHVCQUFRLENBQUMsSUFBSSxFQUFFO0lBQzlDLEtBQUssRUFBRSxJQUFJO0lBQ1gsSUFBSSxFQUFFLElBQUk7Q0FDVixDQUFDLENBQUM7QUFFSCxTQUFnQixRQUFRLENBQUMsT0FJeEIsRUFBRSxVQUFvQjtJQUV0QixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFDaEI7UUFDQyxNQUFNLElBQUksU0FBUyxDQUFDLG1CQUFtQixPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQTtLQUN0RDtJQUVELElBQUksRUFBVSxDQUFDO0lBRWYsSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsRUFDL0I7UUFDQyxFQUFFLEdBQUcscUJBQXFCLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ3hDO0lBRUQsSUFBSSxHQUFHLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFbkMsSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLElBQUksSUFBSSxJQUFJLFVBQVUsQ0FBQyxDQUFDLEVBQ3JGO1FBQ0MsSUFBSSxHQUFHLEdBQUcsSUFBSSxTQUFTLENBQUMsbURBQW1ELE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQzNGLE1BQU0sR0FBRyxDQUFDO0tBQ1Y7SUFFRCxJQUFJLFlBQVksR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQztJQUNwQyxJQUFJLFdBQVcsR0FBRyxZQUFZLElBQUksRUFBRSxLQUFLLEdBQUcsQ0FBQztJQUM3QyxJQUFJLElBQUksR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBRW5DLE9BQU87UUFDTixHQUFHO1FBQ0gsRUFBRTtRQUNGLFlBQVk7UUFDWixXQUFXO1FBQ1gsSUFBSTtLQUNKLENBQUE7QUFDRixDQUFDO0FBckNELDRCQXFDQztBQUVELFNBQWdCLFlBQVksQ0FBQyxZQUFvQixFQUFFLFlBQW9CO0lBRXRFLElBQUksRUFBRSxHQUFhLEVBQUUsQ0FBQztJQUV0QixJQUFJLENBQUMsR0FBRywwQkFBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDM0QsR0FBRyxDQUFDLDRCQUFnQixDQUFDLGNBQWMsQ0FBQztTQUNwQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ3JCO0lBRUQsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDZCxDQUFDO0FBVkQsb0NBVUM7QUFFRCxTQUFnQixVQUFVLENBQUMsSUFBWTtJQUV0QyxJQUFJLGFBQWEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQztJQUVqRCxJQUFJLGVBQWUsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBRW5ELElBQUksWUFBWSxHQUFHLGVBQWUsSUFBSSxFQUFFLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUM7SUFFckYsT0FBTztRQUNOLGFBQWE7UUFDYixlQUFlO1FBQ2YsWUFBWTtLQUNaLENBQUE7QUFDRixDQUFDO0FBYkQsZ0NBYUM7QUFFRCxTQUFnQixTQUFTLENBQUMsSUFBYyxFQUFFLElBRXpDO0lBRUEsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQTtBQUNoRCxDQUFDO0FBTEQsOEJBS0M7QUFFWSxRQUFBLGNBQWMsR0FBRyw2QkFBc0IsQ0FBQyxlQUFPLENBQUMsQ0FBQztBQUU5RCxrQkFBZSxPQUFtQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVkIGJ5IHVzZXIgb24gMjAxOS80LzMwLlxuICovXG5cbmltcG9ydCBmaW5kWWFybldvcmtzcGFjZVJvb3QgPSByZXF1aXJlKCdmaW5kLXlhcm4td29ya3NwYWNlLXJvb3QyJyk7XG5pbXBvcnQgcGtnRGlyID0gcmVxdWlyZSgncGtnLWRpcicpO1xuaW1wb3J0IHsgRGlmZlNlcnZpY2UgfSBmcm9tICd5YXJuLWxvY2stZGlmZi9saWIvZGlmZi1zZXJ2aWNlJztcbmltcG9ydCB7IEZvcm1hdHRlclNlcnZpY2UgfSBmcm9tICd5YXJuLWxvY2stZGlmZi9saWIvZm9ybWF0dGVyJztcbmltcG9ydCB7IENvbnNvbGUyIH0gZnJvbSAnZGVidWctY29sb3IyJztcbmltcG9ydCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuaW1wb3J0IGZzID0gcmVxdWlyZSgnZnMtZXh0cmEnKTtcbmltcG9ydCB7IGNyZWF0ZUZuQ2hhbGtCeUNvbnNvbGUgfSBmcm9tICdkZWJ1Zy1jb2xvcjIvbGliL3V0aWwnO1xuXG5leHBvcnQgY29uc3QgY29uc29sZSA9IG5ldyBDb25zb2xlMigpO1xuXG5leHBvcnQgY29uc3QgY29uc29sZURlYnVnID0gbmV3IENvbnNvbGUyKG51bGwsIHtcblx0bGFiZWw6IHRydWUsXG5cdHRpbWU6IHRydWUsXG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRSb290KG9wdGlvbnM6IHtcblx0Y3dkOiBzdHJpbmcsXG5cdHNraXBDaGVja1dvcmtzcGFjZT86IGJvb2xlYW4gfCBzdHJpbmcsXG5cdHRocm93RXJyb3I/OiBib29sZWFuLFxufSwgdGhyb3dFcnJvcj86IGJvb2xlYW4pXG57XG5cdGlmICghb3B0aW9ucy5jd2QpXG5cdHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBvcHRpb25zLmN3ZCBpcyAnJHtvcHRpb25zLmN3ZH0nYClcblx0fVxuXG5cdGxldCB3czogc3RyaW5nO1xuXG5cdGlmICghb3B0aW9ucy5za2lwQ2hlY2tXb3Jrc3BhY2UpXG5cdHtcblx0XHR3cyA9IGZpbmRZYXJuV29ya3NwYWNlUm9vdChvcHRpb25zLmN3ZCk7XG5cdH1cblxuXHRsZXQgcGtnID0gcGtnRGlyLnN5bmMob3B0aW9ucy5jd2QpO1xuXG5cdGlmIChwa2cgPT0gbnVsbCAmJiAob3B0aW9ucy50aHJvd0Vycm9yIHx8IChvcHRpb25zLnRocm93RXJyb3IgPT0gbnVsbCAmJiB0aHJvd0Vycm9yKSkpXG5cdHtcblx0XHRsZXQgZXJyID0gbmV3IFR5cGVFcnJvcihgY2FuJ3QgZm91bmQgcGFja2FnZSByb290IGZyb20gdGFyZ2V0IGRpcmVjdG9yeSAnJHtvcHRpb25zLmN3ZH0nYCk7XG5cdFx0dGhyb3cgZXJyO1xuXHR9XG5cblx0bGV0IGhhc1dvcmtzcGFjZSA9IHdzICYmIHdzICE9IG51bGw7XG5cdGxldCBpc1dvcmtzcGFjZSA9IGhhc1dvcmtzcGFjZSAmJiB3cyA9PT0gcGtnO1xuXHRsZXQgcm9vdCA9IGhhc1dvcmtzcGFjZSA/IHdzIDogcGtnO1xuXG5cdHJldHVybiB7XG5cdFx0cGtnLFxuXHRcdHdzLFxuXHRcdGhhc1dvcmtzcGFjZSxcblx0XHRpc1dvcmtzcGFjZSxcblx0XHRyb290LFxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5YXJuTG9ja0RpZmYoeWFybmxvY2tfb2xkOiBzdHJpbmcsIHlhcm5sb2NrX25ldzogc3RyaW5nKTogc3RyaW5nXG57XG5cdGxldCByMjogc3RyaW5nW10gPSBbXTtcblxuXHRsZXQgciA9IERpZmZTZXJ2aWNlLmJ1aWxkRGlmZihbeWFybmxvY2tfb2xkXSwgW3lhcm5sb2NrX25ld10pXG5cdFx0Lm1hcChGb3JtYXR0ZXJTZXJ2aWNlLmJ1aWxkRGlmZlRhYmxlKVxuXHRcdC5tYXAociA9PiByMi5wdXNoKHIpKVxuXHQ7XG5cblx0cmV0dXJuIHIyWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnNZYXJuTG9jayhyb290OiBzdHJpbmcpXG57XG5cdGxldCB5YXJubG9ja19maWxlID0gcGF0aC5qb2luKHJvb3QsICd5YXJuLmxvY2snKTtcblxuXHRsZXQgeWFybmxvY2tfZXhpc3RzID0gZnMuZXhpc3RzU3luYyh5YXJubG9ja19maWxlKTtcblxuXHRsZXQgeWFybmxvY2tfb2xkID0geWFybmxvY2tfZXhpc3RzICYmIGZzLnJlYWRGaWxlU3luYyh5YXJubG9ja19maWxlLCAndXRmOCcpIHx8IG51bGw7XG5cblx0cmV0dXJuIHtcblx0XHR5YXJubG9ja19maWxlLFxuXHRcdHlhcm5sb2NrX2V4aXN0cyxcblx0XHR5YXJubG9ja19vbGQsXG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxhenlGbGFncyhrZXlzOiBzdHJpbmdbXSwgYXJndjoge1xuXHRbazogc3RyaW5nXTogYm9vbGVhbixcbn0pXG57XG5cdHJldHVybiBrZXlzLm1hcChrZXkgPT4gYXJndltrZXldICYmICctLScgKyBrZXkpXG59XG5cbmV4cG9ydCBjb25zdCBjaGFsa0J5Q29uc29sZSA9IGNyZWF0ZUZuQ2hhbGtCeUNvbnNvbGUoY29uc29sZSk7XG5cbmV4cG9ydCBkZWZhdWx0IGV4cG9ydHMgYXMgdHlwZW9mIGltcG9ydCgnLi9pbmRleCcpO1xuIl19